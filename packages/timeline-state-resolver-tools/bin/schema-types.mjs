#!/usr/bin/env node
/* eslint-disable */

import { compile, compileFromFile } from 'json-schema-to-typescript'
import * as fs from 'fs/promises'
import * as path from 'path'
import meow from 'meow'
import { createRequire } from 'module'

/** ********************************************************
 *
 * This script goes through the json-schemas of all devices (located under /$schemas )
 * and auto-generates types for those schemas
 *
 ***********************************************************/

const cli = meow(
	`
	Tool to generate typescript types from tsr device json schemas
	It is recommended to run this script on the output of the "tsr-schema-deref" script

	Usage
		$ tsr-schema-types <search-path> <output-path>

	Examples
		$ tsr-schema-types ./src/$schemas/generated ./src/generated/types
`,
	{
		importMeta: import.meta,
		flags: {
			isMainRepository: {
				type: 'boolean',
				default: false,
				description: 'Set to true if running in the main repository',
			},
		},
	}
)

const searchPath = cli.input[0]
const outputPath = cli.input[1]
const isMainRepository = cli.flags.isMainRepository

if (!searchPath || !outputPath) {
	cli.showHelp()
	process.exit(1)
}

const BANNER =
	'/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and re-run the "tsr-schema-types" tool to regenerate this file.\n */\n'

let hadError = false

const capitalise = (s) => {
	if (!s) return s
	const base = s.slice(0, 1).toUpperCase() + s.slice(1)

	// replace `_a` with `A`
	return base.replace(/_[a-z]/gi, (v) => {
		return v.slice(1).toUpperCase()
	})
}

let PrettierConf = undefined
try {
	const require = createRequire(import.meta.url)
	// TODO - this doesn't work. perhaps this should be an argument too?
	const confPath = require.resolve('@sofie-automation/code-standard-preset/.prettierrc.json')
	PrettierConf = JSON.parse(await fs.readFile(confPath))
} catch (e) {
	console.log(e)
	console.warn(`Failed to resolve prettier config path, skipping prettier formatting`)
}

const basePath = path.resolve(searchPath)
const resolvedOutputPath = path.resolve(outputPath)
const dirs = (await fs.readdir(basePath, { withFileTypes: true })).filter((c) => c.isDirectory()).map((d) => d.name)

// Re-create output folder for generated types
await fs.rm(resolvedOutputPath, { recursive: true, force: true })
await fs.mkdir(resolvedOutputPath, { recursive: true })

let indexFile = BANNER + `\n`
let baseMappingsTypes = []

// iterate over integrations
for (const dir of dirs) {
	const dirPath = path.join(basePath, dir)

	// Avoid deferencing recursively
	if (dirPath.startsWith(resolvedOutputPath)) continue

	const dirId = capitalise(dir)

	let output = ''

	// compile options from file
	try {
		const filePath = path.join(dirPath, 'options.json')
		if (await fsExists(filePath)) {
			const options = await compileFromFile(filePath, {
				additionalProperties: false,
				style: PrettierConf,
				bannerComment: '',
				enableConstEnums: false,
			})
			output += '\n' + options
		}
	} catch (e) {
		console.error('Error while generating options for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	// compile mappings from file
	const mappingIds = []
	try {
		const filePath = path.join(dirPath, 'mappings.json')
		if (await fsExists(filePath)) {
			const mappingDescr = JSON.parse(await fs.readFile(filePath))
			for (const [id, mapping] of Object.entries(mappingDescr.mappings)) {
				mappingIds.push(id)

				// Perform some tweaks of the schema for mappingType, which is required to be defined based on the id
				mapping.title = `Mapping${dirId}${capitalise(id)}`
				mapping.properties['mappingType'] = {
					type: 'constant',
					tsType: `Mapping${dirId}Type.${capitalise(id)}`,
				}

				if (!mapping.required) mapping.required = []
				if (!mapping.required.includes('mappingType')) mapping.required.push('mappingType')

				const mappingTypes = await compile(mapping, id + 'Mapping', {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
					enableConstEnums: false,
				})
				output += '\n' + mappingTypes
			}
		}
	} catch (e) {
		console.error('Error while generating mappings for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	// very crude way to create an enum and union for the mappings:
	const mappingTypes = []
	if (mappingIds.length > 0) {
		let mappingsEnum = 'export enum Mapping' + dirId + 'Type {\n'
		for (const id of mappingIds) {
			mappingTypes.push(`Mapping${dirId}${capitalise(id)}`)
			mappingsEnum += '\t' + capitalise(id) + " = '" + id + "',\n"
		}
		mappingsEnum += '}\n'

		output += '\n' + mappingsEnum
	}

	const someMappingName = `SomeMapping${dirId}`
	baseMappingsTypes.push(someMappingName)
	output += '\n' + `export type ${someMappingName} = ${mappingTypes.join(' | ') || 'Record<string, never>'}\n`

	// compile actions from file
	const actionDefinitions = []

	try {
		const filePath = path.join(dirPath, 'actions.json')
		if (await fsExists(filePath)) {
			const actionsDescr = JSON.parse(await fs.readFile(filePath))
			for (const action of actionsDescr.actions) {
				const actionDefinition = {
					id: action.id,
					payloadId: undefined,
					resultId: undefined,
				}
				actionDefinitions.push(actionDefinition)
				if (action.generic) continue

				const actionTypes = []
				// Payload:
				if (action.payload) {
					actionDefinition.payloadId = action.payload.id || capitalise(action.id + 'Payload')
					actionTypes.push(
						await compile(action.payload, actionDefinition.payloadId, {
							additionalProperties: false,
							style: PrettierConf,
							bannerComment: '',
							enableConstEnums: false,
						})
					)
				}
				// Return Data:
				if (action.result) {
					actionDefinition.resultId = action.result.id || capitalise(action.id + 'Result')
					actionTypes.push(
						await compile(action.result, actionDefinition.resultId, {
							additionalProperties: false,
							style: PrettierConf,
							bannerComment: '',
							enableConstEnums: false,
						})
					)
				}

				if (actionTypes.length) {
					output += '\n' + actionTypes.join('\n')
				}
			}
		}
	} catch (e) {
		console.error('Error while generating actions for ' + dirPath + ', continuing...')
		console.error(e)
		hadError = true
	}

	if (actionDefinitions.length > 0) {
		// An enum for all action ids:

		output += `
export enum ${dirId}Actions {
${actionDefinitions
	.map((actionDefinition) => `\t${capitalise(actionDefinition.id)} = '${actionDefinition.id}'`)
	.join(',\n')}
}`
		// An interface for all the action methods:
		output += `
export interface ${dirId}ActionExecutionResults {
${actionDefinitions
	.map(
		(actionDefinition) =>
			`\t${actionDefinition.id}: (${actionDefinition.payloadId ? `payload: ${actionDefinition.payloadId}` : ''}) => ${
				actionDefinition.resultId || 'void'
			}`
	)
	.join(',\n')}
}`
		// Prepend import:
		output =
			`import { ActionExecutionResult } from "${isMainRepository ? '..' : 'timeline-state-resolver-types'}"\n` + output

		// A helper type used to access the action methods payload:
		output += `
export type ${dirId}ActionExecutionPayload<A extends keyof ${dirId}ActionExecutionResults> = Parameters<
	${dirId}ActionExecutionResults[A]
>[0]
`
		// A helper type used to access the action methods return Data:
		output += `
export type ${dirId}ActionExecutionResult<A extends keyof ${dirId}ActionExecutionResults> =
	ActionExecutionResult<ReturnType<${dirId}ActionExecutionResults[A]>>
`
	}

	// Output to tsr types package
	const outputFilePath = path.join(resolvedOutputPath, dir + '.ts')
	if (output) {
		output = BANNER + output

		await fs.writeFile(outputFilePath, output)

		indexFile += `\nexport * from './${dir}'`
		indexFile += `\nimport { ${someMappingName} } from './${dir}'`
		indexFile += '\n'
	} else {
		if (await fsUnlink(outputFilePath)) console.log('Removed ' + outputFilePath)
	}
}

if (baseMappingsTypes.length) {
	indexFile += `\nexport type TSRMappingOptions =\n\t| ${baseMappingsTypes.join('\n\t| ')}`
}

// Output the tsr-types index file
await fs.writeFile(path.join(resolvedOutputPath, 'index.ts'), indexFile + '\n')

// Finally
process.exit(hadError ? 1 : 0)

async function fsExists(filePath) {
	try {
		await fs.access(filePath, fs.F_OK)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false
		throw e
	}
}
async function fsUnlink(filePath) {
	try {
		await fs.unlink(filePath)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false // File doesn't exist, that's okay
		throw e
	}
}
