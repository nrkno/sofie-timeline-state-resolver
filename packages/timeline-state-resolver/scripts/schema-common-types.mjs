/* eslint-disable */
import { compile } from 'json-schema-to-typescript'
import * as fs from 'fs/promises'

/** ********************************************************
 *
 * This script goes through the json-schemas of all devices (located under /$schemas )
 * and auto-generates types for those schemas
 *
 * @todo: auto generate the interfaces.ts in /src as well
 *
 ***********************************************************/
const BANNER =
	'/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run "yarn generate-schema-types" to regenerate this file.\n */\n'

let hadError = false

const capitalise = (s) => {
	if (!s) return s
	const base = s.slice(0, 1).toUpperCase() + s.slice(1)

	// replace `_a` with `A`
	return base.replace(/_[a-z]/gi, (v) => {
		return v.slice(1).toUpperCase()
	})
}

const PrettierConf = JSON.parse(
	await fs.readFile('../../node_modules/@sofie-automation/code-standard-preset/.prettierrc.json')
)

// convert action-schema
try {
	const actionSchemaDescr = JSON.parse(await fs.readFile('../timeline-state-resolver-api/$schemas/action-schema.json'))
	const actionSchema = await compile(actionSchemaDescr.properties.actions.items, 'TSRActionSchema', {
		enableConstEnums: false,
		additionalProperties: false,
		style: PrettierConf,
		bannerComment: '',
	})

	await fs.writeFile('../timeline-state-resolver-types/src/generated/action-schema.ts', BANNER + '\n' + actionSchema)
} catch (e) {
	console.error('Error while generating action-schema.json, continuing...')
	console.error(e)
	hadError = true
}

// convert generic PTZ actions
try {
	const actionsDescr = JSON.parse(await fs.readFile('./src/$schemas/generic-ptz-actions.json'))
	const actionDefinitions = []
	let output = ''
	for (const action of actionsDescr.actions) {
		let actionTypes = []
		const actionDefinition = {
			id: action.id,
			payloadId: undefined,
			resultId: undefined,
		}
		actionDefinitions.push(actionDefinition)
		// Payload:
		if (action.payload) {
			actionDefinition.payloadId = action.payload.id || capitalise(action.id + 'Payload')
			actionTypes.push(
				await compile(action.payload, actionDefinition.payloadId, {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
					enableConstEnums: false,
				})
			)
		}
		// Return Data:
		if (action.result) {
			actionDefinition.resultId = action.result.id || capitalise(action.id + 'Result')
			actionTypes.push(
				await compile(action.result, actionDefinition.resultId, {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
					enableConstEnums: false,
				})
			)
		}
		output += '\n' + actionTypes.join('\n')
	}

	await fs.writeFile('../timeline-state-resolver-types/src/generated/generic-ptz-actions.ts', BANNER + '\n' + output)
} catch (e) {
	console.error('Error while generating common-options.json, continuing...')
	console.error(e)
}

// convert common-options
try {
	const commonOptionsDescr = JSON.parse(await fs.readFile('./src/$schemas/common-options.json'))
	const commonOptionsSchema = await compile(commonOptionsDescr, 'DeviceCommonOptions', {
		additionalProperties: false,
		style: PrettierConf,
		bannerComment: '',
		enableConstEnums: false,
	})

	await fs.writeFile(
		'../timeline-state-resolver-types/src/generated/common-options.ts',
		BANNER + '\n' + commonOptionsSchema
	)
} catch (e) {
	console.error('Error while generating common-options.json, continuing...')
	console.error(e)
	hadError = true
}

// Inject the generated types into the index.ts file
// This is a bit of a hack, but it avoids changing the import paths for now
await fs.writeFile(
	'../timeline-state-resolver-types/src/generated/index.ts',
	`\nexport * from './action-schema'\nexport * from './generic-ptz-actions'\n`,
	{ flag: 'a+' }
)

// Finally
process.exit(hadError ? 1 : 0)
