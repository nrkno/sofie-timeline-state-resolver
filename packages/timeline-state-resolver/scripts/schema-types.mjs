import { compile, compileFromFile } from 'json-schema-to-typescript'
import * as fs from 'fs/promises'
import * as path from 'path'

/** ********************************************************
 *
 * This script goes through the json-schemas of all devices (located under /$schemas )
 * and auto-generates types for those schemas
 *
 * @todo: auto generate the interfaces.ts in /src as well
 * @todo: write meta schemas for options & mappings
 *
 ***********************************************************/
const BANNER =
	'/* eslint-disable */\n/**\n * This file was automatically generated by json-schema-to-typescript.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n * and run "yarn generate-schema-types" to regenerate this file.\n */\n'

const PrettierConf = JSON.parse(
	await fs.readFile('../../node_modules/@sofie-automation/code-standard-preset/.prettierrc.json')
)

// convert action-schema
// compile options from file
try {
	const actionSchema = await compileFromFile('./src/$schemas/action-schema.json', {
		additionalProperties: false,
		style: PrettierConf,
		bannerComment: '',
	})

	await fs.writeFile('../timeline-state-resolver-types/src/generated/action-schema.ts', BANNER + '\n' + actionSchema)
} catch (e) {
	console.error('Error while generating action-schema.json, continuing...')
	console.error(e)
}

const basePath = path.resolve('./src/integrations/')
const dirs = (await fs.readdir(basePath, { withFileTypes: true })).filter((c) => c.isDirectory()).map((d) => d.name)

const capitalise = (s) => s.slice(0, 1).toUpperCase() + s.slice(1)

let indexFile = BANNER + `\nexport * from './action-schema'`

// iterate over integrations
for (const dir of dirs) {
	const dirPath = path.join(basePath, dir)

	let output = ''

	// compile options from file
	try {
		const filePath = path.join(dirPath, '$schemas/options.json')
		if (await fsExists(filePath)) {
			const options = await compileFromFile(filePath, {
				additionalProperties: false,
				style: PrettierConf,
				bannerComment: '',
			})
			output += '\n' + options
		}
	} catch (e) {
		console.error('Error while generating options for ' + dirPath + ', continuing...')
		console.error(e)
	}

	// compile mappings from file
	try {
		const filePath = path.join(dirPath, '$schemas/mappings.json')
		if (await fsExists(filePath)) {
			const mappingDescr = JSON.parse(await fs.readFile(filePath))
			for (const mapping of mappingDescr) {
				const mappingTypes = await compile(mapping, 'Mappings', {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
				})
				output += '\n' + mappingTypes
			}
		}
	} catch (e) {
		console.error('Error while generating mappings for ' + dirPath + ', continuing...')
		console.error(e)
	}

	// compile actions from file
	const actionIds = []
	try {
		const filePath = path.join(dirPath, '$schemas/actions.json')
		if (await fsExists(filePath)) {
			const actionsDescr = JSON.parse(await fs.readFile(filePath))
			for (const action of actionsDescr.actions) {
				actionIds.push(action.id)
				if (!action.payload) continue

				const actionTypes = await compile(action.payload, action.id + 'Payload', {
					additionalProperties: false,
					style: PrettierConf,
					bannerComment: '',
				})
				output += '\n' + actionTypes
			}
		}
	} catch (e) {
		console.error('Error while generating actions for ' + dirPath + ', continuing...')
		console.error(e)
	}

	// very crude way to create an enum for the actionIds:
	if (actionIds.length > 0) {
		let actionEnum = 'export enum ' + capitalise(dir) + 'Actions {\n'
		for (const id of actionIds) {
			actionEnum += '\t' + capitalise(id) + " = '" + id + "',\n"
		}
		actionEnum += '}\n'

		output += '\n' + actionEnum
	}

	// Output to tsr types package
	const outputFilePath = path.join('../timeline-state-resolver-types/src/generated', dir + '.ts')
	if (output) {
		output = BANNER + output

		await fs.writeFile(outputFilePath, output)

		indexFile += `\nexport * from './${dir}'`
	} else {
		if (await fsUnlink(outputFilePath)) console.log('Removed ' + outputFilePath)
	}
}

// Output the tsr-types index file
await fs.writeFile('../timeline-state-resolver-types/src/generated/index.ts', indexFile + '\n')

async function fsExists(filePath) {
	try {
		await fs.access(filePath, fs.F_OK)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false
		throw e
	}
}
async function fsUnlink(filePath) {
	try {
		await fs.unlink(filePath)
		return true
	} catch (e) {
		if (`${e}`.match(/ENOENT/)) return false // File doesn't exist, that's okay
		throw e
	}
}
